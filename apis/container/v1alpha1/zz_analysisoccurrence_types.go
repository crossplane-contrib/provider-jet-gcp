/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AnalysisOccurrenceObservation struct {
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	UpdateTime *string `json:"updateTime,omitempty" tf:"update_time,omitempty"`
}

type AnalysisOccurrenceParameters struct {

	// Occurrence that represents a single "attestation". The authenticity
	// of an attestation can be verified using the attached signature.
	// If the verifier trusts the public key of the signer, then verifying
	// the signature is sufficient to establish trust. In this circumstance,
	// the authority to which this attestation is attached is primarily
	// useful for lookup (how to find this attestation if you already
	// know the authority and artifact to be verified) and intent (for
	// which authority this attestation was intended to sign.
	// +kubebuilder:validation:Required
	Attestation []AttestationParameters `json:"attestation" tf:"attestation,omitempty"`

	// The analysis note associated with this occurrence, in the form of
	// projects/[PROJECT]/notes/[NOTE_ID]. This field can be used as a
	// filter in list requests.
	// +kubebuilder:validation:Required
	NoteName *string `json:"noteName" tf:"note_name,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// A description of actions that can be taken to remedy the note.
	// +kubebuilder:validation:Optional
	Remediation *string `json:"remediation,omitempty" tf:"remediation,omitempty"`

	// Required. Immutable. A URI that represents the resource for which
	// the occurrence applies. For example,
	// https://gcr.io/project/image@sha256:123abc for a Docker image.
	// +kubebuilder:validation:Required
	ResourceURI *string `json:"resourceUri" tf:"resource_uri,omitempty"`
}

type AttestationObservation struct {
}

type AttestationParameters struct {

	// The serialized payload that is verified by one or
	// more signatures. A base64-encoded string.
	// +kubebuilder:validation:Required
	SerializedPayload *string `json:"serializedPayload" tf:"serialized_payload,omitempty"`

	// One or more signatures over serializedPayload.
	// Verifier implementations should consider this attestation
	// message verified if at least one signature verifies
	// serializedPayload. See Signature in common.proto for more
	// details on signature structure and verification.
	// +kubebuilder:validation:Required
	Signatures []SignaturesParameters `json:"signatures" tf:"signatures,omitempty"`
}

type SignaturesObservation struct {
}

type SignaturesParameters struct {

	// The identifier for the public key that verifies this
	// signature. MUST be an RFC3986 conformant
	// URI. * When possible, the key id should be an
	// immutable reference, such as a cryptographic digest.
	// Examples of valid values:
	//
	// * OpenPGP V4 public key fingerprint. See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr
	// for more details on this scheme.
	// * 'openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA'
	// * RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization):
	// * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
	// +kubebuilder:validation:Required
	PublicKeyID *string `json:"publicKeyId" tf:"public_key_id,omitempty"`

	// The content of the signature, an opaque bytestring.
	// The payload that this signature verifies MUST be
	// unambiguously provided with the Signature during
	// verification. A wrapper message might provide the
	// payload explicitly. Alternatively, a message might
	// have a canonical serialization that can always be
	// unambiguously computed to derive the payload.
	// +kubebuilder:validation:Optional
	Signature *string `json:"signature,omitempty" tf:"signature,omitempty"`
}

// AnalysisOccurrenceSpec defines the desired state of AnalysisOccurrence
type AnalysisOccurrenceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AnalysisOccurrenceParameters `json:"forProvider"`
}

// AnalysisOccurrenceStatus defines the observed state of AnalysisOccurrence.
type AnalysisOccurrenceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AnalysisOccurrenceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AnalysisOccurrence is the Schema for the AnalysisOccurrences API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcpjet}
type AnalysisOccurrence struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AnalysisOccurrenceSpec   `json:"spec"`
	Status            AnalysisOccurrenceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AnalysisOccurrenceList contains a list of AnalysisOccurrences
type AnalysisOccurrenceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AnalysisOccurrence `json:"items"`
}

// Repository type metadata.
var (
	AnalysisOccurrence_Kind             = "AnalysisOccurrence"
	AnalysisOccurrence_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AnalysisOccurrence_Kind}.String()
	AnalysisOccurrence_KindAPIVersion   = AnalysisOccurrence_Kind + "." + CRDGroupVersion.String()
	AnalysisOccurrence_GroupVersionKind = CRDGroupVersion.WithKind(AnalysisOccurrence_Kind)
)

func init() {
	SchemeBuilder.Register(&AnalysisOccurrence{}, &AnalysisOccurrenceList{})
}
