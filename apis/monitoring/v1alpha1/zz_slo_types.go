/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AvailabilityObservation struct {
}

type AvailabilityParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to 'true'.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliObservation struct {
}

type BasicSliParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// +kubebuilder:validation:Optional
	Availability []AvailabilityParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// +kubebuilder:validation:Optional
	Latency []LatencyParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +kubebuilder:validation:Optional
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type BasicSliPerformanceAvailabilityObservation struct {
}

type BasicSliPerformanceAvailabilityParameters struct {

	// Whether an availability SLI is enabled or not. Must be set to 'true. Defaults to 'true'.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type BasicSliPerformanceLatencyObservation struct {
}

type BasicSliPerformanceLatencyParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Required
	Threshold *string `json:"threshold" tf:"threshold,omitempty"`
}

type BasicSliPerformanceObservation struct {
}

type BasicSliPerformanceParameters struct {

	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// +kubebuilder:validation:Optional
	Availability []BasicSliPerformanceAvailabilityParameters `json:"availability,omitempty" tf:"availability,omitempty"`

	// Parameters for a latency threshold SLI.
	// +kubebuilder:validation:Optional
	Latency []BasicSliPerformanceLatencyParameters `json:"latency,omitempty" tf:"latency,omitempty"`

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	Location []*string `json:"location,omitempty" tf:"location,omitempty"`

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +kubebuilder:validation:Optional
	Method []*string `json:"method,omitempty" tf:"method,omitempty"`

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	Version []*string `json:"version,omitempty" tf:"version,omitempty"`
}

type DistributionCutObservation struct {
}

type DistributionCutParameters struct {

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// aggregating values to quantify the good service provided.
	//
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Required
	DistributionFilter *string `json:"distributionFilter" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max.
	// +kubebuilder:validation:Required
	Range []RangeParameters `json:"range" tf:"range,omitempty"`
}

type DistributionCutRangeObservation struct {
}

type DistributionCutRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to "infinity", defining an open range
	// ">= range.min"
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to "-infinity", defining an open range
	// "< range.max"
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type GoodTotalRatioObservation struct {
}

type GoodTotalRatioParameters struct {

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	//
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	//
	// Exactly two of 'good_service_filter','bad_service_filter','total_service_filter'
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	//
	// Exactly two of 'good_service_filter','bad_service_filter','total_service_filter'
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying total demanded service.
	//
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	//
	// Exactly two of 'good_service_filter','bad_service_filter','total_service_filter'
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type GoodTotalRatioThresholdObservation struct {
}

type GoodTotalRatioThresholdParameters struct {

	// Basic SLI to evaluate to judge window quality.
	// +kubebuilder:validation:Optional
	BasicSliPerformance []BasicSliPerformanceParameters `json:"basicSliPerformance,omitempty" tf:"basic_sli_performance,omitempty"`

	// Request-based SLI to evaluate to judge window quality.
	// +kubebuilder:validation:Optional
	Performance []PerformanceParameters `json:"performance,omitempty" tf:"performance,omitempty"`

	// If window performance >= threshold, the window is counted
	// as good.
	// +kubebuilder:validation:Optional
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type LatencyObservation struct {
}

type LatencyParameters struct {

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Required
	Threshold *string `json:"threshold" tf:"threshold,omitempty"`
}

type MetricMeanInRangeObservation struct {
}

type MetricMeanInRangeParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Mean value 'X' of 'time_series'
	// values should satisfy 'range.min <= X <= range.max' for a
	// good service.
	// +kubebuilder:validation:Required
	Range []MetricMeanInRangeRangeParameters `json:"range" tf:"range,omitempty"`

	// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// specifying the TimeSeries to use for evaluating window
	// The provided TimeSeries must have ValueType = INT64 or
	// ValueType = DOUBLE and MetricKind = GAUGE. Mean value 'X'
	// should satisfy 'range.min <= X <= range.max'
	// under good service.
	// +kubebuilder:validation:Required
	TimeSeries *string `json:"timeSeries" tf:"time_series,omitempty"`
}

type MetricMeanInRangeRangeObservation struct {
}

type MetricMeanInRangeRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to "infinity", defining an open range
	// ">= range.min"
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to "-infinity", defining an open range
	// "< range.max"
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type MetricSumInRangeObservation struct {
}

type MetricSumInRangeParameters struct {

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value 'X' should satisfy
	// 'range.min <= X <= range.max' for a good window.
	// +kubebuilder:validation:Required
	Range []MetricSumInRangeRangeParameters `json:"range" tf:"range,omitempty"`

	// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	//
	// Summed value 'X' should satisfy
	// 'range.min <= X <= range.max' for a good window.
	// +kubebuilder:validation:Required
	TimeSeries *string `json:"timeSeries" tf:"time_series,omitempty"`
}

type MetricSumInRangeRangeObservation struct {
}

type MetricSumInRangeRangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to "infinity", defining an open range
	// ">= range.min"
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to "-infinity", defining an open range
	// "< range.max"
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type PerformanceDistributionCutObservation struct {
}

type PerformanceDistributionCutParameters struct {

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// aggregating values to quantify the good service provided.
	//
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Required
	DistributionFilter *string `json:"distributionFilter" tf:"distribution_filter,omitempty"`

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max.
	// +kubebuilder:validation:Required
	Range []DistributionCutRangeParameters `json:"range" tf:"range,omitempty"`
}

type PerformanceGoodTotalRatioObservation struct {
}

type PerformanceGoodTotalRatioParameters struct {

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality. Exactly two of
	// good, bad, or total service filter must be defined (where
	// good + bad = total is assumed)
	//
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	BadServiceFilter *string `json:"badServiceFilter,omitempty" tf:"bad_service_filter,omitempty"`

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying good service provided. Exactly two of
	// good, bad, or total service filter must be defined (where
	// good + bad = total is assumed)
	//
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	GoodServiceFilter *string `json:"goodServiceFilter,omitempty" tf:"good_service_filter,omitempty"`

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying total demanded service. Exactly two of
	// good, bad, or total service filter must be defined (where
	// good + bad = total is assumed)
	//
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	TotalServiceFilter *string `json:"totalServiceFilter,omitempty" tf:"total_service_filter,omitempty"`
}

type PerformanceObservation struct {
}

type PerformanceParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// +kubebuilder:validation:Optional
	DistributionCut []PerformanceDistributionCutParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of 'good_service' to 'total_service'.
	// Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// +kubebuilder:validation:Optional
	GoodTotalRatio []PerformanceGoodTotalRatioParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type RangeObservation struct {
}

type RangeParameters struct {

	// max value for the range (inclusive). If not given,
	// will be set to "infinity", defining an open range
	// ">= range.min"
	// +kubebuilder:validation:Optional
	Max *float64 `json:"max,omitempty" tf:"max,omitempty"`

	// Min value for the range (inclusive). If not given,
	// will be set to "-infinity", defining an open range
	// "< range.max"
	// +kubebuilder:validation:Optional
	Min *float64 `json:"min,omitempty" tf:"min,omitempty"`
}

type RequestBasedSliObservation struct {
}

type RequestBasedSliParameters struct {

	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	//
	// Exactly one of 'distribution_cut' or 'good_total_ratio' can be set.
	// +kubebuilder:validation:Optional
	DistributionCut []DistributionCutParameters `json:"distributionCut,omitempty" tf:"distribution_cut,omitempty"`

	// A means to compute a ratio of 'good_service' to 'total_service'.
	// Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	//
	// Exactly one of 'distribution_cut' or 'good_total_ratio' can be set.
	// +kubebuilder:validation:Optional
	GoodTotalRatio []GoodTotalRatioParameters `json:"goodTotalRatio,omitempty" tf:"good_total_ratio,omitempty"`
}

type SLOObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SLOParameters struct {

	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	//
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	//
	// Exactly one of the following must be set:
	// 'basic_sli', 'request_based_sli', 'windows_based_sli'
	// +kubebuilder:validation:Optional
	BasicSli []BasicSliParameters `json:"basicSli,omitempty" tf:"basic_sli,omitempty"`

	// A calendar period, semantically "since the start of the current
	// <calendarPeriod>". Possible values: ["DAY", "WEEK", "FORTNIGHT", "MONTH"]
	// +kubebuilder:validation:Optional
	CalendarPeriod *string `json:"calendarPeriod,omitempty" tf:"calendar_period,omitempty"`

	// Name used for UI elements listing this SLO.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	// +kubebuilder:validation:Required
	Goal *float64 `json:"goal" tf:"goal,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	//
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// 'basic_sli', 'request_based_sli', 'windows_based_sli'
	// +kubebuilder:validation:Optional
	RequestBasedSli []RequestBasedSliParameters `json:"requestBasedSli,omitempty" tf:"request_based_sli,omitempty"`

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	// +kubebuilder:validation:Optional
	RollingPeriodDays *float64 `json:"rollingPeriodDays,omitempty" tf:"rolling_period_days,omitempty"`

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	// +kubebuilder:validation:Optional
	SLOID *string `json:"sloId,omitempty" tf:"slo_id,omitempty"`

	// ID of the service to which this SLO belongs.
	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	//
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	//
	// Exactly one of the following must be set:
	// 'basic_sli', 'request_based_sli', 'windows_based_sli'
	// +kubebuilder:validation:Optional
	WindowsBasedSli []WindowsBasedSliParameters `json:"windowsBasedSli,omitempty" tf:"windows_based_sli,omitempty"`
}

type WindowsBasedSliObservation struct {
}

type WindowsBasedSliParameters struct {

	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of 'good_bad_metric_filter',
	// 'good_total_ratio_threshold', 'metric_mean_in_range',
	// 'metric_sum_in_range' must be set for 'windows_based_sli'.
	// +kubebuilder:validation:Optional
	GoodBadMetricFilter *string `json:"goodBadMetricFilter,omitempty" tf:"good_bad_metric_filter,omitempty"`

	// Criterion that describes a window as good if its performance is
	// high enough. One of 'good_bad_metric_filter',
	// 'good_total_ratio_threshold', 'metric_mean_in_range',
	// 'metric_sum_in_range' must be set for 'windows_based_sli'.
	// +kubebuilder:validation:Optional
	GoodTotalRatioThreshold []GoodTotalRatioThresholdParameters `json:"goodTotalRatioThreshold,omitempty" tf:"good_total_ratio_threshold,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, *averaged* across returned streams.
	// One of 'good_bad_metric_filter',
	//
	// 'good_total_ratio_threshold', 'metric_mean_in_range',
	// 'metric_sum_in_range' must be set for 'windows_based_sli'.
	// Average value X of 'time_series' should satisfy
	// 'range.min <= X <= range.max' for a good window.
	// +kubebuilder:validation:Optional
	MetricMeanInRange []MetricMeanInRangeParameters `json:"metricMeanInRange,omitempty" tf:"metric_mean_in_range,omitempty"`

	// Criterion that describes a window as good if the metric's value
	// is in a good range, *summed* across returned streams.
	// Summed value 'X' of 'time_series' should satisfy
	// 'range.min <= X <= range.max' for a good window.
	//
	// One of 'good_bad_metric_filter',
	// 'good_total_ratio_threshold', 'metric_mean_in_range',
	// 'metric_sum_in_range' must be set for 'windows_based_sli'.
	// +kubebuilder:validation:Optional
	MetricSumInRange []MetricSumInRangeParameters `json:"metricSumInRange,omitempty" tf:"metric_sum_in_range,omitempty"`

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	// +kubebuilder:validation:Optional
	WindowPeriod *string `json:"windowPeriod,omitempty" tf:"window_period,omitempty"`
}

// SLOSpec defines the desired state of SLO
type SLOSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SLOParameters `json:"forProvider"`
}

// SLOStatus defines the observed state of SLO.
type SLOStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SLOObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SLO is the Schema for the SLOs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcpjet}
type SLO struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SLOSpec   `json:"spec"`
	Status            SLOStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SLOList contains a list of SLOs
type SLOList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SLO `json:"items"`
}

// Repository type metadata.
var (
	SLO_Kind             = "SLO"
	SLO_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SLO_Kind}.String()
	SLO_KindAPIVersion   = SLO_Kind + "." + CRDGroupVersion.String()
	SLO_GroupVersionKind = CRDGroupVersion.WithKind(SLO_Kind)
)

func init() {
	SchemeBuilder.Register(&SLO{}, &SLOList{})
}
