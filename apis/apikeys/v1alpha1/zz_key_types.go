/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type APITargetsObservation struct {
}

type APITargetsParameters struct {

	// Optional. List of one or more methods that can be called. If empty, all methods for the service are allowed. A wildcard (*) can be used as the last symbol. Valid examples: `google.cloud.translate.v2.TranslateService.GetSupportedLanguage` `TranslateText` `Get*` `translate.googleapis.com.Get*`
	// +kubebuilder:validation:Optional
	Methods []*string `json:"methods,omitempty" tf:"methods,omitempty"`

	// The service for this restriction. It should be the canonical service name, for example: `translate.googleapis.com`. You can use `gcloud services list` to get a list of services that are enabled in the project.
	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`
}

type AllowedApplicationsObservation struct {
}

type AllowedApplicationsParameters struct {

	// The package name of the application.
	// +kubebuilder:validation:Required
	PackageName *string `json:"packageName" tf:"package_name,omitempty"`

	// The SHA1 fingerprint of the application. For example, both sha1 formats are acceptable : DA:39:A3:EE:5E:6B:4B:0D:32:55:BF:EF:95:60:18:90:AF:D8:07:09 or DA39A3EE5E6B4B0D3255BFEF95601890AFD80709. Output format is the latter.
	// +kubebuilder:validation:Required
	Sha1Fingerprint *string `json:"sha1Fingerprint" tf:"sha1_fingerprint,omitempty"`
}

type AndroidKeyRestrictionsObservation struct {
}

type AndroidKeyRestrictionsParameters struct {

	// A list of Android applications that are allowed to make API calls with this key.
	// +kubebuilder:validation:Required
	AllowedApplications []AllowedApplicationsParameters `json:"allowedApplications" tf:"allowed_applications,omitempty"`
}

type BrowserKeyRestrictionsObservation struct {
}

type BrowserKeyRestrictionsParameters struct {

	// A list of regular expressions for the referrer URLs that are allowed to make API calls with this key.
	// +kubebuilder:validation:Required
	AllowedReferrers []*string `json:"allowedReferrers" tf:"allowed_referrers,omitempty"`
}

type IosKeyRestrictionsObservation struct {
}

type IosKeyRestrictionsParameters struct {

	// A list of bundle IDs that are allowed when making API calls with this key.
	// +kubebuilder:validation:Required
	AllowedBundleIds []*string `json:"allowedBundleIds" tf:"allowed_bundle_ids,omitempty"`
}

type KeyObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type KeyParameters struct {

	// Human-readable display name of this API key. Modifiable by user.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The resource name of the key. The name must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. In another word, the name must match the regular expression: [a-z]([a-z0-9-]{0,61}[a-z0-9])?.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The project for the resource
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// Key restrictions.
	// +kubebuilder:validation:Optional
	Restrictions []RestrictionsParameters `json:"restrictions,omitempty" tf:"restrictions,omitempty"`
}

type RestrictionsObservation struct {
}

type RestrictionsParameters struct {

	// A restriction for a specific service and optionally one or more specific methods. Requests are allowed if they match any of these restrictions. If no restrictions are specified, all targets are allowed.
	// +kubebuilder:validation:Optional
	APITargets []APITargetsParameters `json:"apiTargets,omitempty" tf:"api_targets,omitempty"`

	// The Android apps that are allowed to use the key.
	// +kubebuilder:validation:Optional
	AndroidKeyRestrictions []AndroidKeyRestrictionsParameters `json:"androidKeyRestrictions,omitempty" tf:"android_key_restrictions,omitempty"`

	// The HTTP referrers (websites) that are allowed to use the key.
	// +kubebuilder:validation:Optional
	BrowserKeyRestrictions []BrowserKeyRestrictionsParameters `json:"browserKeyRestrictions,omitempty" tf:"browser_key_restrictions,omitempty"`

	// The iOS apps that are allowed to use the key.
	// +kubebuilder:validation:Optional
	IosKeyRestrictions []IosKeyRestrictionsParameters `json:"iosKeyRestrictions,omitempty" tf:"ios_key_restrictions,omitempty"`

	// The IP addresses of callers that are allowed to use the key.
	// +kubebuilder:validation:Optional
	ServerKeyRestrictions []ServerKeyRestrictionsParameters `json:"serverKeyRestrictions,omitempty" tf:"server_key_restrictions,omitempty"`
}

type ServerKeyRestrictionsObservation struct {
}

type ServerKeyRestrictionsParameters struct {

	// A list of the caller IP addresses that are allowed to make API calls with this key.
	// +kubebuilder:validation:Required
	AllowedIps []*string `json:"allowedIps" tf:"allowed_ips,omitempty"`
}

// KeySpec defines the desired state of Key
type KeySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KeyParameters `json:"forProvider"`
}

// KeyStatus defines the observed state of Key.
type KeyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KeyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Key is the Schema for the Keys API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcpjet}
type Key struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              KeySpec   `json:"spec"`
	Status            KeyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KeyList contains a list of Keys
type KeyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Key `json:"items"`
}

// Repository type metadata.
var (
	Key_Kind             = "Key"
	Key_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Key_Kind}.String()
	Key_KindAPIVersion   = Key_Kind + "." + CRDGroupVersion.String()
	Key_GroupVersionKind = CRDGroupVersion.WithKind(Key_Kind)
)

func init() {
	SchemeBuilder.Register(&Key{}, &KeyList{})
}
