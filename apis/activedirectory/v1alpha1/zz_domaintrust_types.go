/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DomainTrustObservation struct {
}

type DomainTrustParameters struct {

	// The fully qualified domain name. e.g. mydomain.myorganization.com, with the restrictions,
	// https://cloud.google.com/managed-microsoft-ad/reference/rest/v1/projects.locations.global.domains.
	// +kubebuilder:validation:Required
	Domain *string `json:"domain" tf:"domain,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// Whether the trusted side has forest/domain wide access or selective access to an approved set of resources.
	// +kubebuilder:validation:Optional
	SelectiveAuthentication *bool `json:"selectiveAuthentication,omitempty" tf:"selective_authentication,omitempty"`

	// The target DNS server IP addresses which can resolve the remote domain involved in the trust.
	// +kubebuilder:validation:Required
	TargetDNSIPAddresses []*string `json:"targetDnsIpAddresses" tf:"target_dns_ip_addresses,omitempty"`

	// The fully qualified target domain name which will be in trust with the current domain.
	// +kubebuilder:validation:Required
	TargetDomainName *string `json:"targetDomainName" tf:"target_domain_name,omitempty"`

	// The trust direction, which decides if the current domain is trusted, trusting, or both. Possible values: ["INBOUND", "OUTBOUND", "BIDIRECTIONAL"]
	// +kubebuilder:validation:Required
	TrustDirection *string `json:"trustDirection" tf:"trust_direction,omitempty"`

	// The trust secret used for the handshake with the target domain. This will not be stored.
	// +kubebuilder:validation:Required
	TrustHandshakeSecretSecretRef v1.SecretKeySelector `json:"trustHandshakeSecretSecretRef" tf:"-"`

	// The type of trust represented by the trust resource. Possible values: ["FOREST", "EXTERNAL"]
	// +kubebuilder:validation:Required
	TrustType *string `json:"trustType" tf:"trust_type,omitempty"`
}

// DomainTrustSpec defines the desired state of DomainTrust
type DomainTrustSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DomainTrustParameters `json:"forProvider"`
}

// DomainTrustStatus defines the observed state of DomainTrust.
type DomainTrustStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DomainTrustObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DomainTrust is the Schema for the DomainTrusts API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcpjet}
type DomainTrust struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DomainTrustSpec   `json:"spec"`
	Status            DomainTrustStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DomainTrustList contains a list of DomainTrusts
type DomainTrustList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DomainTrust `json:"items"`
}

// Repository type metadata.
var (
	DomainTrust_Kind             = "DomainTrust"
	DomainTrust_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DomainTrust_Kind}.String()
	DomainTrust_KindAPIVersion   = DomainTrust_Kind + "." + CRDGroupVersion.String()
	DomainTrust_GroupVersionKind = CRDGroupVersion.WithKind(DomainTrust_Kind)
)

func init() {
	SchemeBuilder.Register(&DomainTrust{}, &DomainTrustList{})
}
