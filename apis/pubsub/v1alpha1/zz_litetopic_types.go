/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CapacityObservation struct {
}

type CapacityParameters struct {

	// Subscribe throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
	// +kubebuilder:validation:Required
	PublishMibPerSec *int64 `json:"publishMibPerSec" tf:"publish_mib_per_sec,omitempty"`

	// Publish throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
	// +kubebuilder:validation:Required
	SubscribeMibPerSec *int64 `json:"subscribeMibPerSec" tf:"subscribe_mib_per_sec,omitempty"`
}

type LiteTopicObservation struct {
}

type LiteTopicParameters struct {

	// Name of the topic.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The settings for this topic's partitions.
	// +kubebuilder:validation:Optional
	PartitionConfig []PartitionConfigParameters `json:"partitionConfig,omitempty" tf:"partition_config,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// The region of the pubsub lite topic.
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The settings for this topic's Reservation usage.
	// +kubebuilder:validation:Optional
	ReservationConfig []ReservationConfigParameters `json:"reservationConfig,omitempty" tf:"reservation_config,omitempty"`

	// The settings for a topic's message retention.
	// +kubebuilder:validation:Optional
	RetentionConfig []RetentionConfigParameters `json:"retentionConfig,omitempty" tf:"retention_config,omitempty"`

	// The zone of the pubsub lite topic.
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type PartitionConfigObservation struct {
}

type PartitionConfigParameters struct {

	// The capacity configuration.
	// +kubebuilder:validation:Optional
	Capacity []CapacityParameters `json:"capacity,omitempty" tf:"capacity,omitempty"`

	// The number of partitions in the topic. Must be at least 1.
	// +kubebuilder:validation:Required
	Count *int64 `json:"count" tf:"count,omitempty"`
}

type ReservationConfigObservation struct {
}

type ReservationConfigParameters struct {

	// The Reservation to use for this topic's throughput capacity.
	// +kubebuilder:validation:Optional
	ThroughputReservation *string `json:"throughputReservation,omitempty" tf:"throughput_reservation,omitempty"`
}

type RetentionConfigObservation struct {
}

type RetentionConfigParameters struct {

	// The provisioned storage, in bytes, per partition. If the number of bytes stored
	// in any of the topic's partitions grows beyond this value, older messages will be
	// dropped to make room for newer ones, regardless of the value of period.
	// +kubebuilder:validation:Required
	PerPartitionBytes *string `json:"perPartitionBytes" tf:"per_partition_bytes,omitempty"`

	// How long a published message is retained. If unset, messages will be retained as
	// long as the bytes retained for each partition is below perPartitionBytes.
	// +kubebuilder:validation:Optional
	Period *string `json:"period,omitempty" tf:"period,omitempty"`
}

// LiteTopicSpec defines the desired state of LiteTopic
type LiteTopicSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LiteTopicParameters `json:"forProvider"`
}

// LiteTopicStatus defines the observed state of LiteTopic.
type LiteTopicStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LiteTopicObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LiteTopic is the Schema for the LiteTopics API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcpjet}
type LiteTopic struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LiteTopicSpec   `json:"spec"`
	Status            LiteTopicStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LiteTopicList contains a list of LiteTopics
type LiteTopicList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LiteTopic `json:"items"`
}

// Repository type metadata.
var (
	LiteTopic_Kind             = "LiteTopic"
	LiteTopic_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LiteTopic_Kind}.String()
	LiteTopic_KindAPIVersion   = LiteTopic_Kind + "." + CRDGroupVersion.String()
	LiteTopic_GroupVersionKind = CRDGroupVersion.WithKind(LiteTopic_Kind)
)

func init() {
	SchemeBuilder.Register(&LiteTopic{}, &LiteTopicList{})
}
