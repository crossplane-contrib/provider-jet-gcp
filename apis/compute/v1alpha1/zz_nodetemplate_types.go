/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type NodeTemplateObservation struct {
	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`
}

type NodeTemplateParameters struct {

	// CPU overcommit. Default value: "NONE" Possible values: ["ENABLED", "NONE"]
	// +kubebuilder:validation:Optional
	CPUOvercommitType *string `json:"cpuOvercommitType,omitempty" tf:"cpu_overcommit_type,omitempty"`

	// An optional textual description of the resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the resource.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Labels to use for node affinity, which will be used in
	// instance scheduling.
	// +kubebuilder:validation:Optional
	NodeAffinityLabels map[string]*string `json:"nodeAffinityLabels,omitempty" tf:"node_affinity_labels,omitempty"`

	// Node type to use for nodes group that are created from this template.
	// Only one of nodeTypeFlexibility and nodeType can be specified.
	// +kubebuilder:validation:Optional
	NodeType *string `json:"nodeType,omitempty" tf:"node_type,omitempty"`

	// Flexible properties for the desired node type. Node groups that
	// use this node template will create nodes of a type that matches
	// these properties. Only one of nodeTypeFlexibility and nodeType can
	// be specified.
	// +kubebuilder:validation:Optional
	NodeTypeFlexibility []NodeTypeFlexibilityParameters `json:"nodeTypeFlexibility,omitempty" tf:"node_type_flexibility,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// Region where nodes using the node template will be created.
	// If it is not provided, the provider region is used.
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The server binding policy for nodes using this template. Determines
	// where the nodes should restart following a maintenance event.
	// +kubebuilder:validation:Optional
	ServerBinding []ServerBindingParameters `json:"serverBinding,omitempty" tf:"server_binding,omitempty"`
}

type NodeTypeFlexibilityObservation struct {
	LocalSsd *string `json:"localSsd,omitempty" tf:"local_ssd,omitempty"`
}

type NodeTypeFlexibilityParameters struct {

	// Number of virtual CPUs to use.
	// +kubebuilder:validation:Optional
	Cpus *string `json:"cpus,omitempty" tf:"cpus,omitempty"`

	// Physical memory available to the node, defined in MB.
	// +kubebuilder:validation:Optional
	Memory *string `json:"memory,omitempty" tf:"memory,omitempty"`
}

type ServerBindingObservation struct {
}

type ServerBindingParameters struct {

	// Type of server binding policy. If 'RESTART_NODE_ON_ANY_SERVER',
	// nodes using this template will restart on any physical server
	// following a maintenance event.
	//
	// If 'RESTART_NODE_ON_MINIMAL_SERVER', nodes using this template
	// will restart on the same physical server following a maintenance
	// event, instead of being live migrated to or restarted on a new
	// physical server. This option may be useful if you are using
	// software licenses tied to the underlying server characteristics
	// such as physical sockets or cores, to avoid the need for
	// additional licenses when maintenance occurs. However, VMs on such
	// nodes will experience outages while maintenance is applied. Possible values: ["RESTART_NODE_ON_ANY_SERVER", "RESTART_NODE_ON_MINIMAL_SERVERS"]
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

// NodeTemplateSpec defines the desired state of NodeTemplate
type NodeTemplateSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     NodeTemplateParameters `json:"forProvider"`
}

// NodeTemplateStatus defines the observed state of NodeTemplate.
type NodeTemplateStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        NodeTemplateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// NodeTemplate is the Schema for the NodeTemplates API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcpjet}
type NodeTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NodeTemplateSpec   `json:"spec"`
	Status            NodeTemplateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeTemplateList contains a list of NodeTemplates
type NodeTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NodeTemplate `json:"items"`
}

// Repository type metadata.
var (
	NodeTemplate_Kind             = "NodeTemplate"
	NodeTemplate_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: NodeTemplate_Kind}.String()
	NodeTemplate_KindAPIVersion   = NodeTemplate_Kind + "." + CRDGroupVersion.String()
	NodeTemplate_GroupVersionKind = CRDGroupVersion.WithKind(NodeTemplate_Kind)
)

func init() {
	SchemeBuilder.Register(&NodeTemplate{}, &NodeTemplateList{})
}
