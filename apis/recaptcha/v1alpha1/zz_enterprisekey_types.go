/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AndroidSettingsObservation struct {
}

type AndroidSettingsParameters struct {

	// If set to true, it means allowed_package_names will not be enforced.
	// +kubebuilder:validation:Optional
	AllowAllPackageNames *bool `json:"allowAllPackageNames,omitempty" tf:"allow_all_package_names,omitempty"`

	// Android package names of apps allowed to use the key. Example: 'com.companyname.appname'
	// +kubebuilder:validation:Optional
	AllowedPackageNames []*string `json:"allowedPackageNames,omitempty" tf:"allowed_package_names,omitempty"`
}

type EnterpriseKeyObservation struct {
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type EnterpriseKeyParameters struct {

	// Settings for keys that can be used by Android apps.
	// +kubebuilder:validation:Optional
	AndroidSettings []AndroidSettingsParameters `json:"androidSettings,omitempty" tf:"android_settings,omitempty"`

	// Human-readable display name of this key. Modifiable by user.
	// +kubebuilder:validation:Required
	DisplayName *string `json:"displayName" tf:"display_name,omitempty"`

	// Settings for keys that can be used by iOS apps.
	// +kubebuilder:validation:Optional
	IosSettings []IosSettingsParameters `json:"iosSettings,omitempty" tf:"ios_settings,omitempty"`

	// See [Creating and managing labels](https://cloud.google.com/recaptcha-enterprise/docs/labels).
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The project for the resource
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// Options for user acceptance testing.
	// +kubebuilder:validation:Optional
	TestingOptions []TestingOptionsParameters `json:"testingOptions,omitempty" tf:"testing_options,omitempty"`

	// Settings for keys that can be used by websites.
	// +kubebuilder:validation:Optional
	WebSettings []WebSettingsParameters `json:"webSettings,omitempty" tf:"web_settings,omitempty"`
}

type IosSettingsObservation struct {
}

type IosSettingsParameters struct {

	// If set to true, it means allowed_bundle_ids will not be enforced.
	// +kubebuilder:validation:Optional
	AllowAllBundleIds *bool `json:"allowAllBundleIds,omitempty" tf:"allow_all_bundle_ids,omitempty"`

	// iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'
	// +kubebuilder:validation:Optional
	AllowedBundleIds []*string `json:"allowedBundleIds,omitempty" tf:"allowed_bundle_ids,omitempty"`
}

type TestingOptionsObservation struct {
}

type TestingOptionsParameters struct {

	// For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if UNSOLVABLE_CHALLENGE. Possible values: TESTING_CHALLENGE_UNSPECIFIED, NOCAPTCHA, UNSOLVABLE_CHALLENGE
	// +kubebuilder:validation:Optional
	TestingChallenge *string `json:"testingChallenge,omitempty" tf:"testing_challenge,omitempty"`

	// All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
	// +kubebuilder:validation:Optional
	TestingScore *float64 `json:"testingScore,omitempty" tf:"testing_score,omitempty"`
}

type WebSettingsObservation struct {
}

type WebSettingsParameters struct {

	// If set to true, it means allowed_domains will not be enforced.
	// +kubebuilder:validation:Optional
	AllowAllDomains *bool `json:"allowAllDomains,omitempty" tf:"allow_all_domains,omitempty"`

	// If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.
	// +kubebuilder:validation:Optional
	AllowAmpTraffic *bool `json:"allowAmpTraffic,omitempty" tf:"allow_amp_traffic,omitempty"`

	// Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'
	// +kubebuilder:validation:Optional
	AllowedDomains []*string `json:"allowedDomains,omitempty" tf:"allowed_domains,omitempty"`

	// Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE. Possible values: CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED, USABILITY, BALANCE, SECURITY
	// +kubebuilder:validation:Optional
	ChallengeSecurityPreference *string `json:"challengeSecurityPreference,omitempty" tf:"challenge_security_preference,omitempty"`

	// Required. Describes how this key is integrated with the website. Possible values: SCORE, CHECKBOX, INVISIBLE
	// +kubebuilder:validation:Required
	IntegrationType *string `json:"integrationType" tf:"integration_type,omitempty"`
}

// EnterpriseKeySpec defines the desired state of EnterpriseKey
type EnterpriseKeySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     EnterpriseKeyParameters `json:"forProvider"`
}

// EnterpriseKeyStatus defines the observed state of EnterpriseKey.
type EnterpriseKeyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EnterpriseKeyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// EnterpriseKey is the Schema for the EnterpriseKeys API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcpjet}
type EnterpriseKey struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              EnterpriseKeySpec   `json:"spec"`
	Status            EnterpriseKeyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EnterpriseKeyList contains a list of EnterpriseKeys
type EnterpriseKeyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []EnterpriseKey `json:"items"`
}

// Repository type metadata.
var (
	EnterpriseKey_Kind             = "EnterpriseKey"
	EnterpriseKey_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: EnterpriseKey_Kind}.String()
	EnterpriseKey_KindAPIVersion   = EnterpriseKey_Kind + "." + CRDGroupVersion.String()
	EnterpriseKey_GroupVersionKind = CRDGroupVersion.WithKind(EnterpriseKey_Kind)
)

func init() {
	SchemeBuilder.Register(&EnterpriseKey{}, &EnterpriseKeyList{})
}
