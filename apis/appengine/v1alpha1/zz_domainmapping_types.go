/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DomainMappingObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	ResourceRecords []ResourceRecordsObservation `json:"resourceRecords,omitempty" tf:"resource_records,omitempty"`
}

type DomainMappingParameters struct {

	// Relative name of the domain serving the application. Example: example.com.
	// +kubebuilder:validation:Required
	DomainName *string `json:"domainName" tf:"domain_name,omitempty"`

	// Whether the domain creation should override any existing mappings for this domain.
	// By default, overrides are rejected. Default value: "STRICT" Possible values: ["STRICT", "OVERRIDE"]
	// +kubebuilder:validation:Optional
	OverrideStrategy *string `json:"overrideStrategy,omitempty" tf:"override_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// SSL configuration for this domain. If unconfigured, this domain will not serve with SSL.
	// +kubebuilder:validation:Optional
	SslSettings []SslSettingsParameters `json:"sslSettings,omitempty" tf:"ssl_settings,omitempty"`
}

type ResourceRecordsObservation struct {
}

type ResourceRecordsParameters struct {

	// Relative name of the object affected by this record. Only applicable for CNAME records. Example: 'www'.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Data for this record. Values vary by record type, as defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1).
	// +kubebuilder:validation:Optional
	Rrdata *string `json:"rrdata,omitempty" tf:"rrdata,omitempty"`

	// Resource record type. Example: 'AAAA'. Possible values: ["A", "AAAA", "CNAME"]
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SslSettingsObservation struct {
	PendingManagedCertificateID *string `json:"pendingManagedCertificateId,omitempty" tf:"pending_managed_certificate_id,omitempty"`
}

type SslSettingsParameters struct {

	// ID of the AuthorizedCertificate resource configuring SSL for the application. Clearing this field will
	// remove SSL support.
	// By default, a managed certificate is automatically created for every domain mapping. To omit SSL support
	// or to configure SSL manually, specify 'SslManagementType.MANUAL' on a 'CREATE' or 'UPDATE' request. You must be
	// authorized to administer the 'AuthorizedCertificate' resource to manually map it to a DomainMapping resource.
	// Example: 12345.
	// +kubebuilder:validation:Optional
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`

	// SSL management type for this domain. If 'AUTOMATIC', a managed certificate is automatically provisioned.
	// If 'MANUAL', 'certificateId' must be manually specified in order to configure SSL for this domain. Possible values: ["AUTOMATIC", "MANUAL"]
	// +kubebuilder:validation:Required
	SslManagementType *string `json:"sslManagementType" tf:"ssl_management_type,omitempty"`
}

// DomainMappingSpec defines the desired state of DomainMapping
type DomainMappingSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DomainMappingParameters `json:"forProvider"`
}

// DomainMappingStatus defines the observed state of DomainMapping.
type DomainMappingStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DomainMappingObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DomainMapping is the Schema for the DomainMappings API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcpjet}
type DomainMapping struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DomainMappingSpec   `json:"spec"`
	Status            DomainMappingStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DomainMappingList contains a list of DomainMappings
type DomainMappingList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DomainMapping `json:"items"`
}

// Repository type metadata.
var (
	DomainMapping_Kind             = "DomainMapping"
	DomainMapping_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DomainMapping_Kind}.String()
	DomainMapping_KindAPIVersion   = DomainMapping_Kind + "." + CRDGroupVersion.String()
	DomainMapping_GroupVersionKind = CRDGroupVersion.WithKind(DomainMapping_Kind)
)

func init() {
	SchemeBuilder.Register(&DomainMapping{}, &DomainMappingList{})
}
